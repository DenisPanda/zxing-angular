{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../projects/zxing-scanner/src/lib/browser-multi-format-continuous-reader.ts","../../../projects/zxing-scanner/src/lib/zxing-scanner.component.ts","../../../projects/zxing-scanner/src/lib/zxing-scanner.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","pop","length","push","create","__read","o","m","r","i","ar","error","__spread","arguments","concat","BrowserMultiFormatContinuousReader","_super","String","__","constructor","__extends","getScannerControls","scannerControls","Error","scanFromDeviceObservable","deviceId","previewEl","scan$","BehaviorSubject","decodeFromVideoDevice","errorName","name","NotFoundException","ChecksumException","FormatException","message","includes","_this","stop","undefined","ctrls","_b","assign","complete","e_1","_a","asObservable","BrowserMultiFormatReader","ZXingScannerComponent","timeBetweenScans","delayBetweenScanSuccess","previewFitMode","_ready","autostarted","EventEmitter","autostarting","torchCompatible","scanSuccess","scanFailure","scanError","scanComplete","camerasFound","camerasNotFound","permissionResponse","hasDevices","deviceChange","_enabled","_hints","Map","autofocusEnabled","autostart","formats","BarcodeFormat","QR_CODE","hasNavigator","navigator","isMediaDevicesSupported","mediaDevices","defineProperty","_codeReader","_device","device","isAutostarting","console","warn","isCurrentDevice","hasPermission","setDevice","_devicePreStart","hints","get","DecodeHintType","POSSIBLE_FORMATS","input","map","getBarcodeFormatOrFail","set","codeReader","setHints","constraints","controls","streamVideoConstraintsApply","_isAutostarting","state","onOff","getCodeReader","switchTorch","enabled","Boolean","scanFromDevice","init","reset","TRY_HARDER","enable","delete","askForPermission","setPermission","getAnyVideoDevice","stream","_c","permission","handlePermissionException","err_1","terminateStream","getUserMedia","video","getTracks","forEach","initAutostartOn","initAutostartOff","updateVideoInputDevices","devices","autostartScanner","ngOnDestroy","videoEl","previewElemRef","nativeElement","stream_1","srcObject","track","log","ngOnInit","scanStop","_scanSubscription","unsubscribe","scanStart","restart","prevDevice","_reset","BrowserCodeReader","listVideoInputDevices","matcher","test","find","dispatchScanSuccess","getText","dispatchScanFailure","reason","dispatchScanError","observers","some","x","dispatchScanComplete","err","format","trim","toUpperCase","options","delayBetweenScanAttempts","videoElement","scanStream","_onDecodeResult","_onDecodeError","subscribe","closed","hasTorchControl","emit","cleanVideoSource","Component","args","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","ViewChild","static","Input","Output","NgModule","imports","CommonModule","FormsModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { ChecksumException, FormatException, NotFoundException } from '@zxing/library';\nimport { BrowserMultiFormatReader, IScannerControls } from '@zxing/browser';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { ResultAndError } from './ResultAndError';\n\n/**\n * Based on zxing-typescript BrowserCodeReader\n */\nexport class BrowserMultiFormatContinuousReader extends BrowserMultiFormatReader {\n\n  /**\n   * Allows to call scanner controls API while scanning.\n   * Will be undefined if no scanning is runnig.\n   */\n  protected scannerControls: IScannerControls;\n\n  /**\n   * Returns the code reader scanner controls.\n   */\n  public getScannerControls(): IScannerControls {\n    if (!this.scannerControls) {\n      throw new Error('No scanning is running at the time.');\n    }\n    return this.scannerControls;\n  }\n\n  /**\n   * Starts the decoding from the current or a new video element.\n   *\n   * @param deviceId The device's to be used Id\n   * @param previewEl A new video element\n   */\n  public async scanFromDeviceObservable(\n    deviceId?: string,\n    previewEl?: HTMLVideoElement\n  ): Promise<Observable<ResultAndError>> {\n\n    const scan$ = new BehaviorSubject<ResultAndError>({});\n    let ctrls;\n\n    try {\n      ctrls = await this.decodeFromVideoDevice(deviceId, previewEl, (result, error) => {\n\n        if (!error) {\n          scan$.next({ result });\n          return;\n        }\n\n        const errorName = error.name;\n\n        // stream cannot stop on fails.\n        if (\n          // scan Failure - found nothing, no error\n          errorName === NotFoundException.name ||\n          // scan Error - found the QR but got error on decoding\n          errorName === ChecksumException.name ||\n          errorName === FormatException.name ||\n          error.message.includes('No MultiFormat Readers were able to detect the code.')\n        ) {\n          scan$.next({ error });\n          return;\n        }\n\n        // probably fatal error\n        scan$.error(error);\n        this.scannerControls.stop();\n        this.scannerControls = undefined;\n        return;\n      });\n\n      this.scannerControls = {\n        ...ctrls,\n        stop() {\n          ctrls.stop();\n          scan$.complete();\n        },\n      };\n    } catch (e) {\n      scan$.error(e);\n      this.scannerControls?.stop();\n      this.scannerControls = undefined;\n    }\n\n    return scan$.asObservable();\n  }\n}\n","import {\n  ChangeDetectionStrategy,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnInit,\n  Output,\n  ViewChild\n} from '@angular/core';\nimport { BrowserCodeReader } from '@zxing/browser';\nimport {\n  BarcodeFormat,\n  DecodeHintType,\n  Exception,\n  Result\n} from '@zxing/library';\nimport { Subscription } from 'rxjs';\nimport { BrowserMultiFormatContinuousReader } from './browser-multi-format-continuous-reader';\nimport { ResultAndError } from './ResultAndError';\n\n\n@Component({\n  selector: 'zxing-scanner',\n  templateUrl: './zxing-scanner.component.html',\n  styleUrls: ['./zxing-scanner.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ZXingScannerComponent implements OnInit, OnDestroy {\n\n  /**\n   * Supported Hints map.\n   */\n  private _hints: Map<DecodeHintType, any> | null;\n\n  /**\n   * The ZXing code reader.\n   */\n  private _codeReader: BrowserMultiFormatContinuousReader;\n\n  /**\n   * The device that should be used to scan things.\n   */\n  private _device: MediaDeviceInfo;\n\n  /**\n   * The device that should be used to scan things.\n   */\n  private _enabled: boolean;\n\n  /**\n   *\n   */\n  private _isAutostarting: boolean;\n\n  /**\n   * Has `navigator` access.\n   */\n  private hasNavigator: boolean;\n\n  /**\n   * Says if some native API is supported.\n   */\n  private isMediaDevicesSupported: boolean;\n\n  /**\n   * If the user-agent allowed the use of the camera or not.\n   */\n  private hasPermission: boolean | null;\n\n  /**\n   * Unsubscribe to stop scanning.\n   */\n  private _scanSubscription?: Subscription;\n\n  /**\n   * Reference to the preview element, should be the `video` tag.\n   */\n  @ViewChild('preview', { static: true })\n  previewElemRef: ElementRef<HTMLVideoElement>;\n\n  /**\n   * Enable or disable autofocus of the camera (might have an impact on performance)\n   */\n  @Input()\n  autofocusEnabled: boolean;\n\n  /**\n   * Delay between attempts to decode (default is 500ms)\n   */\n  @Input()\n  timeBetweenScans = 500;\n\n  /**\n   * Delay between successful decode (default is 500ms)\n   */\n  @Input()\n  delayBetweenScanSuccess = 500;\n\n  /**\n   * Emits when and if the scanner is autostarted.\n   */\n  @Output()\n  autostarted: EventEmitter<void>;\n\n  /**\n   * True during autostart and false after. It will be null if won't autostart at all.\n   */\n  @Output()\n  autostarting: EventEmitter<boolean>;\n\n  /**\n   * If the scanner should autostart with the first available device.\n   */\n  @Input()\n  autostart: boolean;\n\n  /**\n   * How the preview element shoud be fit inside the :host container.\n   */\n  @Input()\n  previewFitMode: 'fill' | 'contain' | 'cover' | 'scale-down' | 'none' = 'cover';\n\n  /**\n   * Emitts events when the torch compatibility is changed.\n   */\n  @Output()\n  torchCompatible: EventEmitter<boolean>;\n\n  /**\n   * Emitts events when a scan is successful performed, will inject the string value of the QR-code to the callback.\n   */\n  @Output()\n  scanSuccess: EventEmitter<string>;\n\n  /**\n   * Emitts events when a scan fails without errors, usefull to know how much scan tries where made.\n   */\n  @Output()\n  scanFailure: EventEmitter<Exception | undefined>;\n\n  /**\n   * Emitts events when a scan throws some error, will inject the error to the callback.\n   */\n  @Output()\n  scanError: EventEmitter<Error>;\n\n  /**\n   * Emitts events when a scan is performed, will inject the Result value of the QR-code scan (if available) to the callback.\n   */\n  @Output()\n  scanComplete: EventEmitter<Result>;\n\n  /**\n   * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n   */\n  @Output()\n  camerasFound: EventEmitter<MediaDeviceInfo[]>;\n\n  /**\n   * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\n   */\n  @Output()\n  camerasNotFound: EventEmitter<any>;\n\n  /**\n   * Emitts events when the users answers for permission.\n   */\n  @Output()\n  permissionResponse: EventEmitter<boolean>;\n\n  /**\n   * Emitts events when has devices status is update.\n   */\n  @Output()\n  hasDevices: EventEmitter<boolean>;\n\n  private _ready = false;\n\n  private _devicePreStart: MediaDeviceInfo;\n\n  /**\n   * Exposes the current code reader, so the user can use it's APIs.\n   */\n  get codeReader(): BrowserMultiFormatContinuousReader {\n    return this._codeReader;\n  }\n\n  /**\n   * User device input\n   */\n  @Input()\n  set device(device: MediaDeviceInfo | undefined) {\n\n    if (!this._ready) {\n      this._devicePreStart = device;\n      // let's ignore silently, users don't liek logs\n      return;\n    }\n\n    if (this.isAutostarting) {\n      // do not allow setting devices during auto-start, since it will set one and emit it.\n      console.warn('Avoid setting a device during auto-start.');\n      return;\n    }\n\n    if (this.isCurrentDevice(device)) {\n      console.warn('Setting the same device is not allowed.');\n      return;\n    }\n\n    if (!this.hasPermission) {\n      console.warn('Permissions not set yet, waiting for them to be set to apply device change.');\n      // this.permissionResponse\n      //   .pipe(\n      //     take(1),\n      //     tap(() => console.log(`Permissions set, applying device change${device ? ` (${device.deviceId})` : ''}.`))\n      //   )\n      //   .subscribe(() => this.device = device);\n      return;\n    }\n\n    this.setDevice(device);\n  }\n\n  /**\n   * Emits when the current device is changed.\n   */\n  @Output()\n  deviceChange: EventEmitter<MediaDeviceInfo>;\n\n  /**\n   * User device acessor.\n   */\n  get device() {\n    return this._device;\n  }\n\n  /**\n   * Returns all the registered formats.\n   */\n  get formats(): BarcodeFormat[] {\n    return this.hints.get(DecodeHintType.POSSIBLE_FORMATS);\n  }\n\n  /**\n   * Registers formats the scanner should support.\n   *\n   * @param input BarcodeFormat or case-insensitive string array.\n   */\n  @Input()\n  set formats(input: BarcodeFormat[]) {\n\n    if (typeof input === 'string') {\n      throw new Error('Invalid formats, make sure the [formats] input is a binding.');\n    }\n\n    // formats may be set from html template as BarcodeFormat or string array\n    const formats = input.map(f => this.getBarcodeFormatOrFail(f));\n\n    const hints = this.hints;\n\n    // updates the hints\n    hints.set(DecodeHintType.POSSIBLE_FORMATS, formats);\n\n    // handles updating the codeReader\n    this.hints = hints;\n  }\n\n  /**\n   * Returns all the registered hints.\n   */\n  get hints() {\n    return this._hints;\n  }\n\n  /**\n   * Does what it takes to set the hints.\n   */\n  set hints(hints: Map<DecodeHintType, any>) {\n    this._hints = hints;\n    // new instance with new hints.\n    this.codeReader?.setHints(this._hints);\n  }\n\n  /**\n   * Sets the desired constraints in all video tracks.\n   * @experimental\n   */\n  @Input()\n  set videoConstraints(constraints: MediaTrackConstraints) {\n    // new instance with new hints.\n    const controls = this.codeReader?.getScannerControls();\n\n    if (!controls) {\n      // fails silently\n      return;\n    }\n\n    controls?.streamVideoConstraintsApply(constraints);\n  }\n\n  /**\n   *\n   */\n  set isAutostarting(state: boolean) {\n    this._isAutostarting = state;\n    this.autostarting.next(state);\n  }\n\n  /**\n   *\n   */\n  get isAutostarting(): boolean {\n    return this._isAutostarting;\n  }\n\n  /**\n   * Can turn on/off the device flashlight.\n   *\n   * @experimental Torch/Flash APIs are not stable in all browsers, it may be buggy!\n   */\n  @Input()\n  set torch(onOff: boolean) {\n    try {\n      const controls = this.getCodeReader().getScannerControls();\n      controls.switchTorch(onOff);\n    } catch (error) {\n      // ignore error\n    }\n  }\n\n  /**\n   * Starts and Stops the scanning.\n   */\n  @Input()\n  set enable(enabled: boolean) {\n\n    this._enabled = Boolean(enabled);\n\n    if (!this._enabled) {\n      this.reset();\n    } else {\n      if (this.device) {\n        this.scanFromDevice(this.device.deviceId);\n      } else {\n        this.init();\n      }\n    }\n  }\n\n  /**\n   * Tells if the scanner is enabled or not.\n   */\n  get enabled(): boolean {\n    return this._enabled;\n  }\n\n  /**\n   * If is `tryHarder` enabled.\n   */\n  get tryHarder(): boolean {\n    return this.hints.get(DecodeHintType.TRY_HARDER);\n  }\n\n  /**\n   * Enable/disable tryHarder hint.\n   */\n  @Input()\n  set tryHarder(enable: boolean) {\n\n    const hints = this.hints;\n\n    if (enable) {\n      hints.set(DecodeHintType.TRY_HARDER, true);\n    } else {\n      hints.delete(DecodeHintType.TRY_HARDER);\n    }\n\n    this.hints = hints;\n  }\n\n  /**\n   * Constructor to build the object and do some DI.\n   */\n  constructor() {\n    // instance based emitters\n    this.autostarted = new EventEmitter();\n    this.autostarting = new EventEmitter();\n    this.torchCompatible = new EventEmitter(false);\n    this.scanSuccess = new EventEmitter();\n    this.scanFailure = new EventEmitter();\n    this.scanError = new EventEmitter();\n    this.scanComplete = new EventEmitter();\n    this.camerasFound = new EventEmitter();\n    this.camerasNotFound = new EventEmitter();\n    this.permissionResponse = new EventEmitter(true);\n    this.hasDevices = new EventEmitter();\n    this.deviceChange = new EventEmitter();\n\n    this._enabled = true;\n    this._hints = new Map<DecodeHintType, any>();\n    this.autofocusEnabled = true;\n    this.autostart = true;\n    this.formats = [BarcodeFormat.QR_CODE];\n\n    // computed data\n    this.hasNavigator = typeof navigator !== 'undefined';\n    this.isMediaDevicesSupported = this.hasNavigator && !!navigator.mediaDevices;\n  }\n\n  /**\n   * Gets and registers all cammeras.\n   */\n  async askForPermission(): Promise<boolean> {\n\n    if (!this.hasNavigator) {\n      console.error('@zxing/ngx-scanner', 'Can\\'t ask permission, navigator is not present.');\n      this.setPermission(null);\n      return this.hasPermission;\n    }\n\n    if (!this.isMediaDevicesSupported) {\n      console.error('@zxing/ngx-scanner', 'Can\\'t get user media, this is not supported.');\n      this.setPermission(null);\n      return this.hasPermission;\n    }\n\n    let stream: MediaStream;\n    let permission: boolean;\n\n    try {\n      // Will try to ask for permission\n      stream = await this.getAnyVideoDevice();\n      permission = !!stream;\n    } catch (err) {\n      return this.handlePermissionException(err);\n    } finally {\n      this.terminateStream(stream);\n    }\n\n    this.setPermission(permission);\n\n    // Returns the permission\n    return permission;\n  }\n\n  /**\n   *\n   */\n  getAnyVideoDevice(): Promise<MediaStream> {\n    return navigator.mediaDevices.getUserMedia({ video: true });\n  }\n\n  /**\n   * Terminates a stream and it's tracks.\n   */\n  private terminateStream(stream: MediaStream) {\n\n    if (stream) {\n      stream.getTracks().forEach(t => t.stop());\n    }\n\n    stream = undefined;\n  }\n\n  private async init() {\n    if (!this.autostart) {\n      console.warn('Feature \\'autostart\\' disabled. Permissions and devices recovery has to be run manually.');\n\n      // does the necessary configuration without autostarting\n      this.initAutostartOff();\n\n      this._ready = true;\n\n      return;\n    }\n\n    // configurates the component and starts the scanner\n    await this.initAutostartOn();\n\n    this._ready = true;\n  }\n\n  /**\n   * Initializes the component without starting the scanner.\n   */\n  private initAutostartOff(): void {\n\n    // do not ask for permission when autostart is off\n    this.isAutostarting = false;\n\n    // just update devices information\n    this.updateVideoInputDevices();\n\n    if (this._device && this._devicePreStart) {\n      this.setDevice(this._devicePreStart);\n    }\n  }\n\n  /**\n   * Initializes the component and starts the scanner.\n   * Permissions are asked to accomplish that.\n   */\n  private async initAutostartOn(): Promise<void> {\n\n    this.isAutostarting = true;\n\n    let hasPermission: boolean;\n\n    try {\n      // Asks for permission before enumerating devices so it can get all the device's info\n      hasPermission = await this.askForPermission();\n    } catch (e) {\n      console.error('Exception occurred while asking for permission:', e);\n      return;\n    }\n\n    // from this point, things gonna need permissions\n    if (hasPermission) {\n      const devices = await this.updateVideoInputDevices();\n      await this.autostartScanner([...devices]);\n    }\n\n    this.isAutostarting = false;\n    this.autostarted.next();\n  }\n\n  /**\n   * Checks if the given device is the current defined one.\n   */\n  isCurrentDevice(device?: MediaDeviceInfo) {\n    return device?.deviceId === this._device?.deviceId;\n  }\n\n  /**\n   * Executes some actions before destroy the component.\n   */\n  async ngOnDestroy(): Promise<any> {\n    let stream = await this.getAnyVideoDevice();\n    this.terminateStream(stream);\n    return new Promise((resolve) => {\n      const videoEl = this.previewElemRef.nativeElement\n\n      if (videoEl) {\n        const stream = videoEl.srcObject as MediaStream;\n\n        if (stream) {\n\n          const tracks = stream.getTracks();\n\n          tracks.forEach(function(track) {\n            track.stop();\n          });\n\n          videoEl.srcObject = null;\n        } else {\n          console.log('No stream available', {videoEl})\n        }\n      } else {\n        console.log('No video stream', {videoEl});\n      }\n\n      this.reset();\n      resolve(null);\n    })\n  }\n\n  /**\n   *\n   */\n  ngOnInit(): void {\n    this.init();\n  }\n\n  /**\n   * Stops the scanning, if any.\n   */\n  public scanStop() {\n    if (this._scanSubscription) {\n      this.codeReader?.getScannerControls().stop();\n      this._scanSubscription?.unsubscribe();\n      this._scanSubscription = undefined;\n    }\n    this.torchCompatible.next(false);\n  }\n\n  /**\n   * Stops the scanning, if any.\n   */\n  public scanStart() {\n\n    if (this._scanSubscription) {\n      throw new Error('There is already a scan proccess running.');\n    }\n\n    if (!this._device) {\n      throw new Error('No device defined, cannot start scan, please define a device.');\n    }\n\n    this.scanFromDevice(this._device.deviceId);\n  }\n\n  /**\n   * Stops old `codeReader` and starts scanning in a new one.\n   */\n  restart(): void {\n    // @note apenas necessario por enquanto causa da Torch\n    this._codeReader = undefined;\n\n    const prevDevice = this._reset();\n\n    if (!prevDevice) {\n      return;\n    }\n\n    this.device = prevDevice;\n  }\n\n  /**\n   * Discovers and updates known video input devices.\n   */\n  async updateVideoInputDevices(): Promise<MediaDeviceInfo[]> {\n\n    // permissions aren't needed to get devices, but to access them and their info\n    const devices = await BrowserCodeReader.listVideoInputDevices() || [];\n    const hasDevices = devices && devices.length > 0;\n\n    // stores discovered devices and updates information\n    this.hasDevices.next(hasDevices);\n    this.camerasFound.next([...devices]);\n\n    if (!hasDevices) {\n      this.camerasNotFound.next();\n    }\n\n    return devices;\n  }\n\n  /**\n   * Starts the scanner with the back camera otherwise take the last\n   * available device.\n   */\n  private async autostartScanner(devices: MediaDeviceInfo[]): Promise<void> {\n\n    const matcher = ({ label }) => /back|trás|rear|traseira|environment|ambiente/gi.test(label);\n\n    // select the rear camera by default, otherwise take the last camera.\n    const device = devices.find(matcher) || devices.pop();\n\n    if (!device) {\n      throw new Error('Impossible to autostart, no input devices available.');\n    }\n\n    await this.setDevice(device);\n\n    this.deviceChange.next(device);\n  }\n\n  /**\n   * Dispatches the scan success event.\n   *\n   * @param result the scan result.\n   */\n  private dispatchScanSuccess(result: Result): void {\n    this.scanSuccess.next(result.getText());\n  }\n\n  /**\n   * Dispatches the scan failure event.\n   */\n  private dispatchScanFailure(reason?: Exception): void {\n    this.scanFailure.next(reason);\n  }\n\n  /**\n   * Dispatches the scan error event.\n   *\n   * @param error the error thing.\n   */\n  private dispatchScanError(error: any): void {\n    if (!this.scanError.observers.some(x => Boolean(x))) {\n      console.error(`zxing scanner component: ${error.name}`, error);\n      console.warn('Use the `(scanError)` property to handle errors like this!');\n    }\n    this.scanError.next(error);\n  }\n\n  /**\n   * Dispatches the scan event.\n   *\n   * @param result the scan result.\n   */\n  private dispatchScanComplete(result: Result): void {\n    this.scanComplete.next(result);\n  }\n\n  /**\n   * Returns the filtered permission.\n   */\n  private handlePermissionException(err: DOMException): boolean {\n\n    // failed to grant permission to video input\n    console.error('@zxing/ngx-scanner', 'Error when asking for permission.', err);\n\n    let permission: boolean;\n\n    switch (err.name) {\n\n      // usually caused by not secure origins\n      case 'NotSupportedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // could not claim\n        permission = null;\n        // can't check devices\n        this.hasDevices.next(null);\n        break;\n\n      // user denied permission\n      case 'NotAllowedError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // claimed and denied permission\n        permission = false;\n        // this means that input devices exists\n        this.hasDevices.next(true);\n        break;\n\n      // the device has no attached input devices\n      case 'NotFoundError':\n        console.warn('@zxing/ngx-scanner', err.message);\n        // no permissions claimed\n        permission = null;\n        // because there was no devices\n        this.hasDevices.next(false);\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n\n      case 'NotReadableError':\n        console.warn('@zxing/ngx-scanner', 'Couldn\\'t read the device(s)\\'s stream, it\\'s probably in use by another app.');\n        // no permissions claimed\n        permission = null;\n        // there are devices, which I couldn't use\n        this.hasDevices.next(false);\n        // tells the listener about the error\n        this.camerasNotFound.next(err);\n        break;\n\n      default:\n        console.warn('@zxing/ngx-scanner', 'I was not able to define if I have permissions for camera or not.', err);\n        // unknown\n        permission = null;\n        // this.hasDevices.next(undefined;\n        break;\n\n    }\n\n    this.setPermission(permission);\n\n    // tells the listener about the error\n    this.permissionResponse.error(err);\n\n    return permission;\n  }\n\n  /**\n   * Returns a valid BarcodeFormat or fails.\n   */\n  private getBarcodeFormatOrFail(format: string | BarcodeFormat): BarcodeFormat {\n    return typeof format === 'string'\n      ? BarcodeFormat[format.trim().toUpperCase()]\n      : format;\n  }\n\n  /**\n   * Retorna um code reader, cria um se nenhume existe.\n   */\n  private getCodeReader(): BrowserMultiFormatContinuousReader {\n\n    if (!this._codeReader) {\n      const options = {\n        delayBetweenScanAttempts: this.timeBetweenScans,\n        delayBetweenScanSuccess: this.delayBetweenScanSuccess,\n      };\n      this._codeReader = new BrowserMultiFormatContinuousReader(this.hints, options);\n    }\n\n    return this._codeReader;\n  }\n\n  /**\n   * Starts the continuous scanning for the given device.\n   *\n   * @param deviceId The deviceId from the device.\n   */\n  private async scanFromDevice(deviceId: string): Promise<void> {\n\n    const videoElement = this.previewElemRef.nativeElement;\n\n    const codeReader = this.getCodeReader();\n\n    const scanStream = await codeReader.scanFromDeviceObservable(deviceId, videoElement);\n\n    if (!scanStream) {\n      throw new Error('Undefined decoding stream, aborting.');\n    }\n\n    const next = (x: ResultAndError) => this._onDecodeResult(x.result, x.error);\n    const error = (err: any) => this._onDecodeError(err);\n    const complete = () => { };\n\n    this._scanSubscription = scanStream.subscribe(next, error, complete);\n\n    if (this._scanSubscription.closed) {\n      return;\n    }\n\n    const controls = codeReader.getScannerControls();\n    const hasTorchControl = typeof controls.switchTorch !== 'undefined';\n\n    this.torchCompatible.next(hasTorchControl);\n  }\n\n  /**\n   * Handles decode errors.\n   */\n  private _onDecodeError(err: any) {\n    this.dispatchScanError(err);\n    // this.reset();\n  }\n\n  /**\n   * Handles decode results.\n   */\n  private _onDecodeResult(result: Result, error: Exception): void {\n\n    if (result) {\n      this.dispatchScanSuccess(result);\n    } else {\n      this.dispatchScanFailure(error);\n    }\n\n    this.dispatchScanComplete(result);\n  }\n\n  /**\n   * Stops the code reader and returns the previous selected device.\n   */\n  private _reset(): MediaDeviceInfo {\n\n    if (!this._codeReader) {\n      return;\n    }\n\n    const device = this._device;\n    // do not set this.device inside this method, it would create a recursive loop\n    this.device = undefined;\n\n    this._codeReader = undefined;\n\n    return device;\n  }\n\n  /**\n   * Resets the scanner and emits device change.\n   */\n  public reset(): void {\n    this._reset();\n    this.deviceChange.emit(null);\n  }\n\n  /**\n   * Sets the current device.\n   */\n  private async setDevice(device: MediaDeviceInfo): Promise<void> {\n\n    // instantly stops the scan before changing devices\n    this.scanStop();\n\n    // correctly sets the new (or none) device\n    this._device = device || undefined;\n\n    if (!this._device) {\n      // cleans the video because user removed the device\n      BrowserCodeReader.cleanVideoSource(this.previewElemRef.nativeElement);\n    }\n\n    // if enabled, starts scanning\n    if (this._enabled && device) {\n      await this.scanFromDevice(device.deviceId);\n    }\n  }\n\n  /**\n   * Sets the permission value and emmits the event.\n   */\n  private setPermission(hasPermission: boolean | null): void {\n    this.hasPermission = hasPermission;\n    this.permissionResponse.next(hasPermission);\n  }\n\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { ZXingScannerComponent } from './zxing-scanner.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    FormsModule\n  ],\n  declarations: [ZXingScannerComponent],\n  exports: [ZXingScannerComponent],\n})\nexport class ZXingScannerModule { }\n"]}